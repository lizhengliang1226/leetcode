package com.lzl;

import java.util.ArrayList;
import java.util.List;

/**
 * 37. 解数独
 * 编写一个程序，通过填充空格来解决数独问题。
 * <p>
 * 数独的解法需 遵循如下规则：
 * <p>
 * 数字 1-9 在每一行只能出现一次。
 * 数字 1-9 在每一列只能出现一次。
 * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 * 数独部分空格内已填入了数字，空白格用 '.' 表示。
 * 示例 1：
 * <p>
 * <p>
 * 输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
 * 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
 * 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
 *
 * @author LZL
 * @version v1.0
 * @date 2022/8/8-13:59
 */
public class SolveSudoku {
    /*
    *
    * 如何判断（3，5）这个位置可以放哪些数？
    首先使用Line[3]|col[5]|block[3/3][5/3]
    或运算：一个为1就是1
    假设：
    Line3:      011000100，3，7，8不能用
    Col5:       100100001，1，6，9不能用
    Block3/35/5:001000100，3，7不能用
    或运算后：    111100101，1，3，6，7，8，9不能用，就拿到了哪些数在这一格不能再使用
    之后取反：11111111111...000011010，表示2，4，5可以填,但此时高位都是1了，因为我们只要前9位，
    * 但是计算机存储最少都是16位，我们不需要高位，需要与000000000111111111这个数相&，此时高位会置零，
    * 而低9位不会受影响，此时就拿到了在i行j列可以放置的数也就是0000000000000011010.表示2，4，5可以放
    想要将一个数的某一位由1转变为0或者由0转变为1该怎么办？
    * 一个数110010100，如果想将其第2位从0变1，将其与1<<2（100）^即可，从1变0也一样，因为00100只有那一位为1，
    * 如果对应的是1，相同为0就变成了0，如果是0，不同为1就变成了1
    * 想要保留一个数的最低一位1，或者去掉最低一位1？
    一个数1010=取反0101+1=0110
    1010&0110=0010，只有最低位的1保留了，所以b&(-b)得到b的最低位的1
    1010^0010=1000 去掉了最低一位1，所以b^(b&(-b))就能够去掉最低一位1
      public void flip(int i, int j, int digit) {
            表示要将i行j列的数字digit设置为已使用，linei本身是000000000，要将数字digit设置上去就是把
            * digit那一位置为1，就使用第二种方法，让其与1<<digit位^,即可将那一位由0转为1，完成行的设置，
            * 列也是一样的，小格子的设置也是一样的
            line[i] ^= (1 << digit);
            column[j] ^= (1 << digit);
            block[i / 3][j / 3] ^= (1 << digit);
        }
        * 要想拿到哪些数在i，j这个位置可以使用，就使用了第一个方法，先或运算，然后取反，
        * 再与0x1ff相&得到哪些数可以使用
        *  int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;
        for (; mask != 0 && !valid; mask &= (mask - 1)) {
            // 这里使用了第三个方法,b&(-b)拿到b的最低位1
            * int digitMask = mask & (-mask);
            * 将原来的最低位1转为整数，原本是二进制的，减一是因为：
            * 假设此时digit为1100，在上一步后digit变为0100，说明要把第三位置为1来表示数字3已经填过了，
            * 所以需要0100（4）-1=3
            int digit = Integer.bitCount(digitMask - 1);
            // 调用方法把line col block都置为1
            * flip(i, j, digit);
            * // 把数字填上去
            board[i][j] = (char) (digit + '0' + 1);
            dfs(board, pos + 1);
            flip(i, j, digit);
        }

    * */
    int[] lines = new int[9];
    int[] columns = new int[9];
    int[][] blocks = new int[3][3];

    boolean[][] rows = new boolean[9][9];
    boolean[][] cols = new boolean[9][9];
    boolean[][][] sub = new boolean[3][3][9];

    List<int[]> spaces = new ArrayList<int[]>();
    boolean valid = false;

    public void solveSudoku(char[][] board) {
        // 先遍历一次将已经填的数字的位置使用情况设置为true
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    // 方法1
                    flip(i, j, c - '0' - 1);
                    // 方法2
//                    int index = c - '0' - 1;
//                    rows[i][index] = true;
//                    cols[j][index] = true;
//                    sub[i / 3][j / 3][index] = true;
                } else {
                    // 对于还未填的位置，将其记录下来
                    spaces.add(new int[]{i, j});
                }
            }
        }
        // 开始递归，从第0各未填的位置开始
//        dfs(board, 0);
        dfs1(board, 0);
    }

    private void dfs1(char[][] board, int pos) {
        // 如果已填的位置已经等于了未填位置的大小，说明所有位置已经填上了，设置有效性为true，返回
        if (pos == spaces.size()) {
            valid = true;
            return;
        }
        // 表示还有未填的位置，将其取出来拿到位置坐标
        final int[] sp = spaces.get(pos);
        int row = sp[0];
        int col = sp[1];
        // 得到哪几个数可以使用
        int mask = ~(lines[row] | columns[col] | blocks[row / 3][col / 3]) & 0x1ff;
        // 在循环过程中，mask的低位1会被不断抹去，最后会变成0
        for (; mask != 0 && !valid; mask ^= (mask & (-mask))) {
            // 得到最低位的1表示的数
            int digitMask = mask & (-mask);
            // 将该数减一后拿到最低位的1后面的位数，例如0100，减一后得到0011，
            // Integer.bitCount()这个方法拿到一个二进制数1的个数，显然会返回2
            int digit = Integer.bitCount(digitMask - 1);
            // 调用flip，此时在该方法内部会将1<<digit位，此时也就是1<<2位得到4，刚好就是100，
            // 也就是把第三位 置为1 表示3被占用，完成填数
            flip(row, col, digit);
            // 此时加1刚好把2变成3，将三填入了，就完成了
            board[row][col] = (char) (digit + '0' + 1);
            dfs1(board, pos + 1);
            // 回溯的时候直接调用就行，因为^操作会将1变0，0变1，所以直接调用就会将之前置为1的部分重新置为0
            // 也就完成了回溯
            flip(row, col, digit);
        }
    }

    private void flip(int i, int j, int digit) {
        // 要将（i，j）这个位置的第digit位置为1，需要让三个数组的对应数与1<<digit位相&
        lines[i] ^= (1 << digit);
        columns[j] ^= (1 << digit);
        blocks[i / 3][j / 3] ^= (1 << digit);
    }

    private void dfs(char[][] board, int pos) {
        // 如果已填的位置已经等于了未填位置的大小，说明所有位置已经填上了，设置有效性为true，返回
        if (pos == spaces.size()) {
            valid = true;
            return;
        }
        // 表示还有未填的位置，将其取出来拿到位置坐标
        final int[] sp = spaces.get(pos);
        int row = sp[0];
        int col = sp[1];
        // 尝试填入数字1-9，且需要有效性为false，因为为true表示已经全部填完，就无需再遍历了
        for (int i = 0; i < 9 && !valid; i++) {
            // 判断行方向，列方向，小格子上都还没使用这个数字
            if (!rows[row][i] && !cols[col][i] && !sub[row / 3][col / 3][i]) {
                // 将状态标为已使用
                rows[row][i] = cols[col][i] = sub[row / 3][col / 3][i] = true;
                // 填入数字
                board[row][col] = (char) (i + '0' + 1);
                // 位置加一，去填下一个位置
                dfs(board, pos + 1);
                // 在这种遍历的情况下会出现还没填完，有的格子已经无数可填，也就是前面填的数字出现了错误
                // 会结束循环回到这里来，此时需要回溯，将之前填的位置设置为false表示没填过
                rows[row][i] = cols[col][i] = sub[row / 3][col / 3][i] = false;
                // 为什么不用将已填过的数字重新设置为‘.’？ 这是因为回溯过来后，pos回到上一个位置，也就是已经填过的这个位置，
                // 此时会进入下一次循环去找合适的数字重新填入，在填入的时候会把之前填的数字覆盖掉，
                // 所以这里数字不用回溯，只用将位置回溯
            }
        }
    }
}